{"ast":null,"code":"import _regeneratorRuntime from \"/Users/jdh/Workgrouper/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/jdh/Workgrouper/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/Users/jdh/Workgrouper/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/jdh/Workgrouper/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport { createContext, useContext, createElement, useMemo, useState as useState$1, useEffect as useEffect$1, useRef as useRef$1, isValidElement, cloneElement, Fragment } from 'react';\nvar VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit'\n};\nvar RADIO_INPUT = 'radio';\nvar FILE_INPUT = 'file';\nvar VALUE = 'value';\nvar UNDEFINED = 'undefined';\nvar EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nvar INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\nvar REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar REGEX_IS_PLAIN_PROP = /^\\w*$/;\nvar REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nvar REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\n\nfunction attachEventListeners(_ref) {\n  var field = _ref.field,\n      handleChange = _ref.handleChange,\n      isRadioOrCheckbox = _ref.isRadioOrCheckbox;\n  var ref = field.ref;\n\n  if (ref.addEventListener) {\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isUndefined = function isUndefined(val) {\n  return val === undefined;\n};\n\nvar isNullOrUndefined = function isNullOrUndefined(value) {\n  return value === null || isUndefined(value);\n};\n\nvar isArray = function isArray(value) {\n  return Array.isArray(value);\n};\n\nvar isObjectType = function isObjectType(value) {\n  return typeof value === 'object';\n};\n\nvar isObject = function isObject(value) {\n  return !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n};\n\nvar isKey = function isKey(value) {\n  return !isArray(value) && (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n};\n\nvar stringToPath = function stringToPath(string) {\n  var result = [];\n  string.replace(REGEX_PROP_NAME, function (match, number, quote, string) {\n    result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  var index = -1;\n  var tempPath = isKey(path) ? [path] : stringToPath(path);\n  var length = tempPath.length;\n  var lastIndex = length - 1;\n\n  while (++index < length) {\n    var key = tempPath[index];\n    var newValue = value;\n\n    if (index !== lastIndex) {\n      var objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = function transformToNestObject(data) {\n  return Object.entries(data).reduce(function (previous, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n\n    if (REGEX_IS_DEEP_PROP.test(key)) {\n      set(previous, key, value);\n      return previous;\n    }\n\n    return Object.assign(Object.assign({}, previous), _defineProperty({}, key, value));\n  }, {});\n};\n\nvar removeAllEventListeners = function removeAllEventListeners(ref, validateWithStateUpdate) {\n  if (ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nvar isRadioInput = function isRadioInput(type) {\n  return type === RADIO_INPUT;\n};\n\nvar isCheckBoxInput = function isCheckBoxInput(type) {\n  return type === 'checkbox';\n};\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\n  if (!field) {\n    return;\n  }\n\n  var ref = field.ref,\n      _field$ref = field.ref,\n      name = _field$ref.name,\n      type = _field$ref.type,\n      mutationWatcher = field.mutationWatcher;\n\n  if (!type) {\n    return;\n  }\n\n  var fieldValue = fields[name];\n\n  if ((isRadioInput(type) || isCheckBoxInput(type)) && fieldValue) {\n    var options = fieldValue.options;\n\n    if (isArray(options) && options.length) {\n      options.forEach(function (_ref4, index) {\n        var ref = _ref4.ref;\n\n        if (ref && isDetached(ref) || forceDelete) {\n          var _mutationWatcher = ref.mutationWatcher;\n          removeAllEventListeners(ref, handleChange);\n\n          if (_mutationWatcher) {\n            _mutationWatcher.disconnect();\n          }\n\n          options.splice(index, 1);\n        }\n      });\n\n      if (options && !options.length) {\n        delete fields[name];\n      }\n    } else {\n      delete fields[name];\n    }\n  } else if (isDetached(ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n\n    delete fields[name];\n  }\n}\n\nvar defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = function getRadioValue(options) {\n  return isArray(options) ? options.reduce(function (previous, _ref5) {\n    var _ref5$ref = _ref5.ref,\n        checked = _ref5$ref.checked,\n        value = _ref5$ref.value;\n    return checked ? {\n      isValid: true,\n      value: value\n    } : previous;\n  }, defaultReturn) : defaultReturn;\n};\n\nvar getMultipleSelectValue = function getMultipleSelectValue(options) {\n  return _toConsumableArray(options).filter(function (_ref6) {\n    var selected = _ref6.selected;\n    return selected;\n  }).map(function (_ref7) {\n    var value = _ref7.value;\n    return value;\n  });\n};\n\nvar isFileInput = function isFileInput(type) {\n  return type === FILE_INPUT;\n};\n\nvar isMultipleSelect = function isMultipleSelect(type) {\n  return type === 'select-multiple';\n};\n\nvar isEmptyString = function isEmptyString(value) {\n  return value === '';\n};\n\nvar defaultResult = {\n  value: false,\n  isValid: false\n};\nvar validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = function getCheckboxValue(options) {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      var values = options.filter(function (_ref8) {\n        var checked = _ref8.ref.checked;\n        return checked;\n      }).map(function (_ref9) {\n        var value = _ref9.ref.value;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    var _options$0$ref = options[0].ref,\n        checked = _options$0$ref.checked,\n        value = _options$0$ref.value,\n        attributes = _options$0$ref.attributes;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || isEmptyString(value) ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fields, ref) {\n  var type = ref.type,\n      name = ref.name,\n      options = ref.options,\n      value = ref.value,\n      files = ref.files;\n  var field = fields[name];\n\n  if (isFileInput(type)) {\n    return files;\n  }\n\n  if (isRadioInput(type)) {\n    return field ? getRadioValue(field.options).value : '';\n  }\n\n  if (isMultipleSelect(type)) {\n    return getMultipleSelectValue(options);\n  }\n\n  if (isCheckBoxInput(type)) {\n    return field ? getCheckboxValue(field.options).value : false;\n  }\n\n  return value;\n}\n\nvar getFieldsValues = function getFieldsValues(fields) {\n  return Object.values(fields).reduce(function (previous, _ref10) {\n    var ref = _ref10.ref,\n        name = _ref10.ref.name;\n    return Object.assign(Object.assign({}, previous), _defineProperty({}, name, getFieldValue(fields, ref)));\n  }, {});\n};\n\nvar isEmptyObject = function isEmptyObject(value) {\n  return isObject(value) && !Object.keys(value).length;\n};\n\nvar isSameError = function isSameError(error, type, message) {\n  return isObject(error) && error.type === type && error.message === message;\n};\n\nvar get = function get(obj, path, defaultValue) {\n  var result = path.split(/[,[\\].]+?/).filter(Boolean).reduce(function (result, key) {\n    return isNullOrUndefined(result) ? result : result[key];\n  }, obj);\n  return isUndefined(result) || result === obj ? obj[path] || defaultValue : result;\n};\n\nfunction shouldUpdateWithError(_ref11) {\n  var errors = _ref11.errors,\n      name = _ref11.name,\n      error = _ref11.error,\n      validFields = _ref11.validFields,\n      fieldsWithValidation = _ref11.fieldsWithValidation;\n  var isFieldValid = isEmptyObject(error);\n  var isFormValid = isEmptyObject(errors);\n  var currentFieldError = get(error, name);\n  var existFieldError = get(errors, name);\n\n  if (isFieldValid && validFields.has(name) || existFieldError && existFieldError.isManual) {\n    return false;\n  }\n\n  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {\n    return true;\n  }\n\n  return currentFieldError && !isSameError(existFieldError, currentFieldError.type, currentFieldError.message);\n}\n\nvar isRegex = function isRegex(value) {\n  return value instanceof RegExp;\n};\n\nvar getValueAndMessage = function getValueAndMessage(validationData) {\n  var isPureObject = isObject(validationData) && !isRegex(validationData);\n  return {\n    value: isPureObject ? validationData.value : validationData,\n    message: isPureObject ? validationData.message : ''\n  };\n};\n\nvar isString = function isString(value) {\n  return typeof value === 'string';\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n\nvar isBoolean = function isBoolean(value) {\n  return typeof value === 'boolean';\n};\n\nfunction getValidateError(result, ref) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n  var isStringValue = isString(result);\n\n  if (isStringValue || isBoolean(result) && !result) {\n    var message = isStringValue ? result : '';\n    return {\n      type: type,\n      message: message,\n      ref: ref\n    };\n  }\n}\n\nvar appendErrors = function appendErrors(name, validateAllFieldCriteria, errors, type, message) {\n  if (!validateAllFieldCriteria) {\n    return {};\n  }\n\n  var error = errors[name];\n  return Object.assign(Object.assign({}, error), {\n    types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), _defineProperty({}, type, message || true))\n  });\n};\n\nvar validateField = function validateField(fieldsRef, validateAllFieldCriteria, _ref12) {\n  var ref, _ref12$ref, type, value, name, valueAsNumber, valueAsDate, options, required, maxLength, minLength, min, max, pattern, validate, fields, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, message, exceedMax, exceedMin, _getValueAndMessage, maxValue, maxMessage, _getValueAndMessage2, minValue, minMessage, valueNumber, valueDate, _getValueAndMessage3, maxLengthValue, maxLengthMessage, _getValueAndMessage4, minLengthValue, minLengthMessage, inputLength, _exceedMax, _exceedMin, _getValueAndMessage5, patternValue, patternMessage, fieldValue, validateRef, result, validateError, validateFunctions, validationResult;\n\n  return _regeneratorRuntime.async(function validateField$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          ref = _ref12.ref, _ref12$ref = _ref12.ref, type = _ref12$ref.type, value = _ref12$ref.value, name = _ref12$ref.name, valueAsNumber = _ref12$ref.valueAsNumber, valueAsDate = _ref12$ref.valueAsDate, options = _ref12.options, required = _ref12.required, maxLength = _ref12.maxLength, minLength = _ref12.minLength, min = _ref12.min, max = _ref12.max, pattern = _ref12.pattern, validate = _ref12.validate;\n          fields = fieldsRef.current;\n          error = {};\n          isRadio = isRadioInput(type);\n          isCheckBox = isCheckBoxInput(type);\n          isRadioOrCheckbox = isRadio || isCheckBox;\n          isEmpty = isEmptyString(value);\n          appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n          getMinMaxMessage = function getMinMaxMessage(exceedMax, maxLengthMessage, minLengthMessage) {\n            var maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n            var minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n            var message = exceedMax ? maxLengthMessage : minLengthMessage;\n            error[name] = Object.assign({\n              type: exceedMax ? maxType : minType,\n              message: message,\n              ref: ref\n            }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n\n            if (!validateAllFieldCriteria) {\n              return error;\n            }\n          };\n\n          if (!(required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid))) {\n            _context2.next = 14;\n            break;\n          }\n\n          message = isString(required) ? required : getValueAndMessage(required).message;\n          error[name] = Object.assign({\n            type: INPUT_VALIDATION_RULES.required,\n            message: message,\n            ref: isRadioOrCheckbox ? fields[name].options[0].ref : ref\n          }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n          if (validateAllFieldCriteria) {\n            _context2.next = 14;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", error);\n\n        case 14:\n          if (!(!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n            _context2.next = 22;\n            break;\n          }\n\n          _getValueAndMessage = getValueAndMessage(max), maxValue = _getValueAndMessage.value, maxMessage = _getValueAndMessage.message;\n          _getValueAndMessage2 = getValueAndMessage(min), minValue = _getValueAndMessage2.value, minMessage = _getValueAndMessage2.message;\n\n          if (type === 'number' || !type && !isNaN(value)) {\n            valueNumber = valueAsNumber || parseFloat(value);\n\n            if (!isNullOrUndefined(maxValue)) {\n              exceedMax = valueNumber > maxValue;\n            }\n\n            if (!isNullOrUndefined(minValue)) {\n              exceedMin = valueNumber < minValue;\n            }\n          } else {\n            valueDate = valueAsDate || new Date(value);\n\n            if (isString(maxValue)) {\n              exceedMax = valueDate > new Date(maxValue);\n            }\n\n            if (isString(minValue)) {\n              exceedMin = valueDate < new Date(minValue);\n            }\n          }\n\n          if (!(exceedMax || exceedMin)) {\n            _context2.next = 22;\n            break;\n          }\n\n          getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n          if (validateAllFieldCriteria) {\n            _context2.next = 22;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", error);\n\n        case 22:\n          if (!(isString(value) && !isEmpty && (maxLength || minLength))) {\n            _context2.next = 32;\n            break;\n          }\n\n          _getValueAndMessage3 = getValueAndMessage(maxLength), maxLengthValue = _getValueAndMessage3.value, maxLengthMessage = _getValueAndMessage3.message;\n          _getValueAndMessage4 = getValueAndMessage(minLength), minLengthValue = _getValueAndMessage4.value, minLengthMessage = _getValueAndMessage4.message;\n          inputLength = value.toString().length;\n          _exceedMax = maxLength && inputLength > maxLengthValue;\n          _exceedMin = minLength && inputLength < minLengthValue;\n\n          if (!(_exceedMax || _exceedMin)) {\n            _context2.next = 32;\n            break;\n          }\n\n          getMinMaxMessage(!!_exceedMax, maxLengthMessage, minLengthMessage);\n\n          if (validateAllFieldCriteria) {\n            _context2.next = 32;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", error);\n\n        case 32:\n          if (!(pattern && !isEmpty)) {\n            _context2.next = 38;\n            break;\n          }\n\n          _getValueAndMessage5 = getValueAndMessage(pattern), patternValue = _getValueAndMessage5.value, patternMessage = _getValueAndMessage5.message;\n\n          if (!(isRegex(patternValue) && !patternValue.test(value))) {\n            _context2.next = 38;\n            break;\n          }\n\n          error[name] = Object.assign({\n            type: INPUT_VALIDATION_RULES.pattern,\n            message: patternMessage,\n            ref: ref\n          }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n          if (validateAllFieldCriteria) {\n            _context2.next = 38;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", error);\n\n        case 38:\n          if (!validate) {\n            _context2.next = 61;\n            break;\n          }\n\n          fieldValue = getFieldValue(fields, ref);\n          validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n          if (!isFunction(validate)) {\n            _context2.next = 52;\n            break;\n          }\n\n          _context2.next = 44;\n          return _regeneratorRuntime.awrap(validate(fieldValue));\n\n        case 44:\n          result = _context2.sent;\n          validateError = getValidateError(result, validateRef);\n\n          if (!validateError) {\n            _context2.next = 50;\n            break;\n          }\n\n          error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            _context2.next = 50;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", error);\n\n        case 50:\n          _context2.next = 61;\n          break;\n\n        case 52:\n          if (!isObject(validate)) {\n            _context2.next = 61;\n            break;\n          }\n\n          validateFunctions = Object.entries(validate);\n          _context2.next = 56;\n          return _regeneratorRuntime.awrap(new Promise(function (resolve) {\n            validateFunctions.reduce(function _callee(previous, _ref13, index) {\n              var _ref14, key, validate, result, validateResult, validateError;\n\n              return _regeneratorRuntime.async(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      _ref14 = _slicedToArray(_ref13, 2), key = _ref14[0], validate = _ref14[1];\n                      _context.t2 = isEmptyObject;\n                      _context.next = 4;\n                      return _regeneratorRuntime.awrap(previous);\n\n                    case 4:\n                      _context.t3 = _context.sent;\n                      _context.t1 = !(0, _context.t2)(_context.t3);\n\n                      if (!_context.t1) {\n                        _context.next = 8;\n                        break;\n                      }\n\n                      _context.t1 = !validateAllFieldCriteria;\n\n                    case 8:\n                      _context.t0 = _context.t1;\n\n                      if (_context.t0) {\n                        _context.next = 11;\n                        break;\n                      }\n\n                      _context.t0 = !isFunction(validate);\n\n                    case 11:\n                      if (!_context.t0) {\n                        _context.next = 13;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", resolve(previous));\n\n                    case 13:\n                      _context.next = 15;\n                      return _regeneratorRuntime.awrap(validate(fieldValue));\n\n                    case 15:\n                      validateResult = _context.sent;\n                      validateError = getValidateError(validateResult, validateRef, key);\n\n                      if (validateError) {\n                        result = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n                        if (validateAllFieldCriteria) {\n                          error[name] = result;\n                        }\n                      } else {\n                        result = previous;\n                      }\n\n                      return _context.abrupt(\"return\", validateFunctions.length - 1 === index ? resolve(result) : result);\n\n                    case 19:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              });\n            }, {});\n          }));\n\n        case 56:\n          validationResult = _context2.sent;\n\n          if (isEmptyObject(validationResult)) {\n            _context2.next = 61;\n            break;\n          }\n\n          error[name] = Object.assign({\n            ref: validateRef\n          }, validationResult);\n\n          if (validateAllFieldCriteria) {\n            _context2.next = 61;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", error);\n\n        case 61:\n          return _context2.abrupt(\"return\", error);\n\n        case 62:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  });\n};\n\nvar parseErrorSchema = function parseErrorSchema(error, validateAllFieldCriteria) {\n  return isArray(error.inner) ? error.inner.reduce(function (previous, _ref15) {\n    var path = _ref15.path,\n        message = _ref15.message,\n        type = _ref15.type;\n    return Object.assign(Object.assign({}, previous), previous[path] && validateAllFieldCriteria ? _defineProperty({}, path, appendErrors(path, validateAllFieldCriteria, previous, type, message)) : _defineProperty({}, path, previous[path] || Object.assign({\n      message: message,\n      type: type\n    }, validateAllFieldCriteria ? {\n      types: _defineProperty({}, type, message || true)\n    } : {})));\n  }, {}) : _defineProperty({}, error.path, {\n    message: error.message,\n    type: error.type\n  });\n};\n\nfunction validateWithSchema(validationSchema, validateAllFieldCriteria, data) {\n  return _regeneratorRuntime.async(function validateWithSchema$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(validationSchema.validate(data, {\n            abortEarly: false\n          }));\n\n        case 3:\n          _context3.t0 = _context3.sent;\n          _context3.t1 = {};\n          return _context3.abrupt(\"return\", {\n            values: _context3.t0,\n            errors: _context3.t1\n          });\n\n        case 8:\n          _context3.prev = 8;\n          _context3.t2 = _context3[\"catch\"](0);\n          return _context3.abrupt(\"return\", {\n            values: {},\n            errors: transformToNestObject(parseErrorSchema(_context3.t2, validateAllFieldCriteria))\n          });\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[0, 8]]);\n}\n\nvar getDefaultValue = function getDefaultValue(defaultValues, name, defaultValue) {\n  return isUndefined(defaultValues[name]) ? get(defaultValues, name, defaultValue) : defaultValues[name];\n};\n\nfunction flatArray(list) {\n  return list.reduce(function (a, b) {\n    return a.concat(isArray(b) ? flatArray(b) : b);\n  }, []);\n}\n\nvar isPrimitive = function isPrimitive(value) {\n  return isNullOrUndefined(value) || !isObjectType(value);\n};\n\nvar getPath = function getPath(path, values) {\n  var getInnerPath = function getInnerPath(value, key, isObject) {\n    var pathWithIndex = isObject ? \"\".concat(path, \".\").concat(key) : \"\".concat(path, \"[\").concat(key, \"]\");\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return isArray(values) ? values.map(function (value, key) {\n    return getInnerPath(value, key);\n  }) : Object.entries(values).map(function (_ref19) {\n    var _ref20 = _slicedToArray(_ref19, 2),\n        key = _ref20[0],\n        value = _ref20[1];\n\n    return getInnerPath(value, key, true);\n  });\n};\n\nvar getPath$1 = function getPath$1(parentPath, value) {\n  return flatArray(getPath(parentPath, value));\n};\n\nvar assignWatchFields = function assignWatchFields(fieldValues, fieldName, watchFields, combinedDefaultValues) {\n  var value;\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else if (!isUndefined(fieldValues[fieldName])) {\n    watchFields.add(fieldName);\n    value = fieldValues[fieldName];\n  } else {\n    value = get(transformToNestObject(fieldValues), fieldName);\n\n    if (!isUndefined(value)) {\n      getPath$1(fieldName, value).forEach(function (name) {\n        return watchFields.add(name);\n      });\n    }\n  }\n\n  return isUndefined(value) ? isObject(combinedDefaultValues) ? getDefaultValue(combinedDefaultValues, fieldName) : combinedDefaultValues : value;\n};\n\nvar skipValidation = function skipValidation(_ref21) {\n  var hasError = _ref21.hasError,\n      isBlurEvent = _ref21.isBlurEvent,\n      isOnSubmit = _ref21.isOnSubmit,\n      isReValidateOnSubmit = _ref21.isReValidateOnSubmit,\n      isOnBlur = _ref21.isOnBlur,\n      isReValidateOnBlur = _ref21.isReValidateOnBlur,\n      isSubmitted = _ref21.isSubmitted;\n  return isOnSubmit && isReValidateOnSubmit || isOnSubmit && !isSubmitted || isOnBlur && !isBlurEvent && !hasError || isReValidateOnBlur && !isBlurEvent && hasError || isReValidateOnSubmit && isSubmitted;\n};\n\nvar isMatchFieldArrayName = function isMatchFieldArrayName(name, searchName) {\n  return name.startsWith(\"\".concat(searchName, \"[\"));\n};\n\nvar isNameInFieldArray = function isNameInFieldArray(names, name) {\n  return _toConsumableArray(names).reduce(function (prev, current) {\n    return isMatchFieldArrayName(name, current) ? true : prev;\n  }, false);\n};\n\nfunction onDomRemove(element, onDetachCallback) {\n  var observer = new MutationObserver(function () {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar omitObject = function omitObject(obj, key) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  var _a = key,\n      omitted = obj[_a],\n      rest = __rest(obj, [typeof _a === \"symbol\" ? _a : _a + \"\"]);\n\n  return rest;\n};\n\nvar unsetObject = function unsetObject(target) {\n  for (var key in target) {\n    var data = target[key];\n    var isArrayObject = isArray(data);\n\n    if ((isObject(data) || isArrayObject) && !data.ref) {\n      unsetObject(data);\n    }\n\n    if (isUndefined(data) || isEmptyObject(data) || isArrayObject && !target[key].filter(Boolean).length) {\n      delete target[key];\n    }\n  }\n\n  return target;\n};\n\nvar unset = function unset(target, paths) {\n  paths.forEach(function (path) {\n    set(target, path, undefined);\n  });\n  return unsetObject(target);\n};\n\nvar modeChecker = function modeChecker(mode) {\n  return {\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\n    isOnChange: mode === VALIDATION_MODE.onChange\n  };\n};\n\nvar useRef = React.useRef,\n    useState = React.useState,\n    useCallback = React.useCallback,\n    useEffect = React.useEffect;\n\nfunction useForm() {\n  var _ref22 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref22$mode = _ref22.mode,\n      mode = _ref22$mode === void 0 ? VALIDATION_MODE.onSubmit : _ref22$mode,\n      _ref22$reValidateMode = _ref22.reValidateMode,\n      reValidateMode = _ref22$reValidateMode === void 0 ? VALIDATION_MODE.onChange : _ref22$reValidateMode,\n      validationSchema = _ref22.validationSchema,\n      _ref22$defaultValues = _ref22.defaultValues,\n      defaultValues = _ref22$defaultValues === void 0 ? {} : _ref22$defaultValues,\n      _ref22$submitFocusErr = _ref22.submitFocusError,\n      submitFocusError = _ref22$submitFocusErr === void 0 ? true : _ref22$submitFocusErr,\n      validateCriteriaMode = _ref22.validateCriteriaMode;\n\n  var fieldsRef = useRef({});\n  var validateAllFieldCriteria = validateCriteriaMode === 'all';\n  var errorsRef = useRef({});\n  var touchedFieldsRef = useRef({});\n  var watchFieldsRef = useRef(new Set());\n  var dirtyFieldsRef = useRef(new Set());\n  var fieldsWithValidationRef = useRef(new Set());\n  var validFieldsRef = useRef(new Set());\n  var isValidRef = useRef(true);\n  var defaultRenderValuesRef = useRef({});\n  var defaultValuesRef = useRef(defaultValues);\n  var isUnMount = useRef(false);\n  var isWatchAllRef = useRef(false);\n  var isSubmittedRef = useRef(false);\n  var isDirtyRef = useRef(false);\n  var submitCountRef = useRef(0);\n  var isSubmittingRef = useRef(false);\n  var handleChangeRef = useRef();\n  var resetFieldArrayFunctionRef = useRef({});\n  var fieldArrayNamesRef = useRef(new Set());\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      render = _useState2[1];\n\n  var _useRef$current = useRef(modeChecker(mode)).current,\n      isOnBlur = _useRef$current.isOnBlur,\n      isOnSubmit = _useRef$current.isOnSubmit;\n  var isWindowUndefined = typeof window === UNDEFINED;\n  var isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\n  var isProxyEnabled = isWeb && 'Proxy' in window;\n  var readFormState = useRef({\n    dirty: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  var _useRef$current2 = useRef(modeChecker(reValidateMode)).current,\n      isReValidateOnBlur = _useRef$current2.isOnBlur,\n      isReValidateOnSubmit = _useRef$current2.isOnSubmit;\n  defaultValuesRef.current = defaultValuesRef.current ? defaultValuesRef.current : defaultValues;\n  var reRender = useCallback(function () {\n    if (!isUnMount.current) {\n      render({});\n    }\n  }, []);\n  var validateFieldCurry = useCallback(validateField.bind(null, fieldsRef, validateAllFieldCriteria), []);\n  var validateFieldsSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validateAllFieldCriteria), [validationSchema]);\n  var renderBaseOnError = useCallback(function (name, error, shouldRender, skipReRender) {\n    var shouldReRender = shouldRender || shouldUpdateWithError({\n      errors: errorsRef.current,\n      error: error,\n      name: name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n\n    if (isEmptyObject(error)) {\n      if (fieldsWithValidationRef.current.has(name) || validationSchema) {\n        validFieldsRef.current.add(name);\n        shouldReRender = shouldReRender || get(errorsRef.current, name);\n      }\n\n      errorsRef.current = unset(errorsRef.current, [name]);\n    } else {\n      validFieldsRef.current.delete(name);\n      shouldReRender = shouldReRender || !get(errorsRef.current, name);\n      set(errorsRef.current, name, error[name]);\n    }\n\n    if (shouldReRender && !skipReRender) {\n      reRender();\n      return true;\n    }\n  }, [reRender, validationSchema]);\n  var setFieldValue = useCallback(function (name, rawValue) {\n    var field = fieldsRef.current[name];\n\n    if (!field) {\n      return false;\n    }\n\n    var ref = field.ref;\n    var type = ref.type;\n    var options = field.options;\n    var value = isWeb && ref instanceof window.HTMLElement && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(type) && options) {\n      options.forEach(function (_ref23) {\n        var radioRef = _ref23.ref;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(type)) {\n      if (value instanceof FileList || value === '') {\n        ref.files = value;\n      } else {\n        ref.value = value;\n      }\n    } else if (isMultipleSelect(type)) {\n      _toConsumableArray(ref.options).forEach(function (selectRef) {\n        return selectRef.selected = value.includes(selectRef.value);\n      });\n    } else if (isCheckBoxInput(type) && options) {\n      options.length > 1 ? options.forEach(function (_ref24) {\n        var checkboxRef = _ref24.ref;\n        return checkboxRef.checked = value.includes(checkboxRef.value);\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n\n    return type;\n  }, [isWeb]);\n\n  var setDirty = function setDirty(name) {\n    if (!fieldsRef.current[name]) {\n      return false;\n    }\n\n    var isDirty = defaultRenderValuesRef.current[name] !== getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\n    var isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;\n\n    if (isDirty) {\n      dirtyFieldsRef.current.add(name);\n    } else {\n      dirtyFieldsRef.current.delete(name);\n    }\n\n    isDirtyRef.current = !!dirtyFieldsRef.current.size;\n    return isDirtyChanged && readFormState.current.dirty;\n  };\n\n  var setInternalValue = useCallback(function (name, value) {\n    setFieldValue(name, value);\n\n    if (setDirty(name) || !get(touchedFieldsRef.current, name) && readFormState.current.touched) {\n      return !!set(touchedFieldsRef.current, name, true);\n    }\n  }, [setFieldValue]);\n  var executeValidation = useCallback(function _callee2(name, shouldRender, skipReRender) {\n    var field, error;\n    return _regeneratorRuntime.async(function _callee2$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            field = fieldsRef.current[name];\n\n            if (field) {\n              _context4.next = 3;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", false);\n\n          case 3:\n            if (shouldRender) {\n              reRender();\n            }\n\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(validateField(fieldsRef, validateAllFieldCriteria, field));\n\n          case 6:\n            error = _context4.sent;\n            renderBaseOnError(name, error, false, skipReRender);\n            return _context4.abrupt(\"return\", isEmptyObject(error));\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    });\n  }, [reRender, renderBaseOnError, validateAllFieldCriteria]);\n  var executeSchemaValidation = useCallback(function _callee3(payload, shouldRender) {\n    var _ref25, errors, previousFormIsValid, fieldName, _error;\n\n    return _regeneratorRuntime.async(function _callee3$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return _regeneratorRuntime.awrap(validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(getFieldsValues(fieldsRef.current))));\n\n          case 2:\n            _ref25 = _context5.sent;\n            errors = _ref25.errors;\n            previousFormIsValid = isValidRef.current;\n            isValidRef.current = isEmptyObject(errors);\n\n            if (isArray(payload)) {\n              payload.forEach(function (name) {\n                if (errors[name]) {\n                  set(errorsRef.current, name, errors[name]);\n                } else {\n                  unset(errorsRef.current, [name]);\n                }\n              });\n              reRender();\n            } else {\n              fieldName = payload;\n              _error = get(errors, fieldName) ? _defineProperty({}, fieldName, get(errors, fieldName)) : {};\n              renderBaseOnError(fieldName, _error, shouldRender || previousFormIsValid !== isValidRef.current);\n            }\n\n            return _context5.abrupt(\"return\", isEmptyObject(errorsRef.current));\n\n          case 8:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    });\n  }, [reRender, renderBaseOnError, validateAllFieldCriteria, validationSchema]);\n  var triggerValidation = useCallback(function _callee5(payload, shouldRender) {\n    var fields, result;\n    return _regeneratorRuntime.async(function _callee5$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            fields = payload || Object.keys(fieldsRef.current);\n\n            if (!validationSchema) {\n              _context7.next = 3;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", executeSchemaValidation(fields, shouldRender));\n\n          case 3:\n            if (!isArray(fields)) {\n              _context7.next = 9;\n              break;\n            }\n\n            _context7.next = 6;\n            return _regeneratorRuntime.awrap(Promise.all(fields.map(function _callee4(data) {\n              return _regeneratorRuntime.async(function _callee4$(_context6) {\n                while (1) {\n                  switch (_context6.prev = _context6.next) {\n                    case 0:\n                      _context6.next = 2;\n                      return _regeneratorRuntime.awrap(executeValidation(data, false, true));\n\n                    case 2:\n                      return _context6.abrupt(\"return\", _context6.sent);\n\n                    case 3:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }\n              });\n            })));\n\n          case 6:\n            result = _context7.sent;\n            reRender();\n            return _context7.abrupt(\"return\", result.every(Boolean));\n\n          case 9:\n            _context7.next = 11;\n            return _regeneratorRuntime.awrap(executeValidation(fields, shouldRender));\n\n          case 11:\n            return _context7.abrupt(\"return\", _context7.sent);\n\n          case 12:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    });\n  }, [executeSchemaValidation, executeValidation, reRender, validationSchema]);\n  var setValue = useCallback(function (name, value, shouldValidate) {\n    var shouldRender = setInternalValue(name, value) || isWatchAllRef.current || watchFieldsRef.current.has(name);\n\n    if (shouldValidate) {\n      return triggerValidation(name, shouldRender);\n    }\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    return;\n  }, [reRender, setInternalValue, triggerValidation]);\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : function _callee6(_ref27) {\n    var type, target, name, fields, errors, field, currentError, error, isBlurEvent, shouldSkipValidation, shouldUpdateDirty, shouldUpdateState, _ref28, _errors, validForm;\n\n    return _regeneratorRuntime.async(function _callee6$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            type = _ref27.type, target = _ref27.target;\n            name = target ? target.name : '';\n            fields = fieldsRef.current;\n            errors = errorsRef.current;\n            field = fields[name];\n            currentError = get(errors, name);\n\n            if (field) {\n              _context8.next = 8;\n              break;\n            }\n\n            return _context8.abrupt(\"return\");\n\n          case 8:\n            isBlurEvent = type === EVENTS.BLUR;\n            shouldSkipValidation = skipValidation({\n              hasError: !!currentError,\n              isBlurEvent: isBlurEvent,\n              isOnSubmit: isOnSubmit,\n              isReValidateOnSubmit: isReValidateOnSubmit,\n              isOnBlur: isOnBlur,\n              isReValidateOnBlur: isReValidateOnBlur,\n              isSubmitted: isSubmittedRef.current\n            });\n            shouldUpdateDirty = setDirty(name);\n            shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current.has(name) || shouldUpdateDirty;\n\n            if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormState.current.touched) {\n              set(touchedFieldsRef.current, name, true);\n              shouldUpdateState = true;\n            }\n\n            if (!shouldSkipValidation) {\n              _context8.next = 15;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", shouldUpdateState && reRender());\n\n          case 15:\n            if (!validationSchema) {\n              _context8.next = 26;\n              break;\n            }\n\n            _context8.next = 18;\n            return _regeneratorRuntime.awrap(validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(getFieldsValues(fields))));\n\n          case 18:\n            _ref28 = _context8.sent;\n            _errors = _ref28.errors;\n            validForm = isEmptyObject(_errors);\n            error = get(_errors, name) ? _defineProperty({}, name, get(_errors, name)) : {};\n\n            if (isValidRef.current !== validForm) {\n              shouldUpdateState = true;\n            }\n\n            isValidRef.current = validForm;\n            _context8.next = 29;\n            break;\n\n          case 26:\n            _context8.next = 28;\n            return _regeneratorRuntime.awrap(validateField(fieldsRef, validateAllFieldCriteria, field));\n\n          case 28:\n            error = _context8.sent;\n\n          case 29:\n            if (!renderBaseOnError(name, error) && shouldUpdateState) {\n              reRender();\n            }\n\n          case 30:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    });\n  };\n  var validateSchemaIsValid = useCallback(function () {\n    var fieldValues = isEmptyObject(defaultValuesRef.current) ? getFieldsValues(fieldsRef.current) : defaultValuesRef.current;\n    validateFieldsSchemaCurry(transformToNestObject(fieldValues)).then(function (_ref30) {\n      var errors = _ref30.errors;\n      var previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n\n      if (previousFormIsValid && previousFormIsValid !== isValidRef.current) {\n        reRender();\n      }\n    });\n  }, [reRender, validateFieldsSchemaCurry]);\n  var resetFieldRef = useCallback(function (name) {\n    errorsRef.current = unset(errorsRef.current, [name]);\n    touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\n    fieldsRef.current = omitObject(fieldsRef.current, name);\n    defaultRenderValuesRef.current = omitObject(defaultRenderValuesRef.current, name);\n    [dirtyFieldsRef, fieldsWithValidationRef, validFieldsRef, watchFieldsRef].forEach(function (data) {\n      return data.current.delete(name);\n    });\n\n    if (readFormState.current.isValid || readFormState.current.touched) {\n      reRender();\n    }\n\n    if (validationSchema) {\n      validateSchemaIsValid();\n    }\n  }, [reRender]);\n  var removeEventListenerAndRef = useCallback(function (field, forceDelete) {\n    if (!field) {\n      return;\n    }\n\n    if (!isUndefined(handleChangeRef.current)) {\n      findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\n    }\n\n    resetFieldRef(field.ref.name);\n  }, [resetFieldRef]);\n\n  function clearError(name) {\n    if (isUndefined(name)) {\n      errorsRef.current = {};\n    } else {\n      (isArray(name) ? name : [name]).forEach(function (fieldName) {\n        return errorsRef.current = omitObject(errorsRef.current, fieldName);\n      });\n    }\n\n    reRender();\n  }\n\n  var setInternalError = function setInternalError(_ref31) {\n    var name = _ref31.name,\n        type = _ref31.type,\n        types = _ref31.types,\n        message = _ref31.message,\n        preventRender = _ref31.preventRender;\n    var field = fieldsRef.current[name];\n\n    if (!isSameError(errorsRef.current[name], type, message)) {\n      set(errorsRef.current, name, {\n        type: type,\n        types: types,\n        message: message,\n        ref: field ? field.ref : {},\n        isManual: true\n      });\n\n      if (!preventRender) {\n        reRender();\n      }\n    }\n  };\n\n  function setError(name) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var message = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (isString(name)) {\n      setInternalError(Object.assign({\n        name: name\n      }, isObject(type) ? {\n        types: type,\n        type: ''\n      } : {\n        type: type,\n        message: message\n      }));\n    } else if (isArray(name)) {\n      name.forEach(function (error) {\n        return setInternalError(Object.assign(Object.assign({}, error), {\n          preventRender: true\n        }));\n      });\n      reRender();\n    }\n  }\n\n  function watch(fieldNames, defaultValue) {\n    var combinedDefaultValues = isUndefined(defaultValue) ? isUndefined(defaultValuesRef.current) ? {} : defaultValuesRef.current : defaultValue;\n    var fieldValues = getFieldsValues(fieldsRef.current);\n    var watchFields = watchFieldsRef.current;\n\n    if (isProxyEnabled) {\n      readFormState.current.dirty = true;\n    }\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, combinedDefaultValues);\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce(function (previous, name) {\n        var value;\n\n        if (isEmptyObject(fieldsRef.current) && isObject(combinedDefaultValues)) {\n          value = getDefaultValue(combinedDefaultValues, name);\n        } else {\n          value = assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues);\n        }\n\n        return Object.assign(Object.assign({}, previous), _defineProperty({}, name, value));\n      }, {});\n    }\n\n    isWatchAllRef.current = true;\n    var result = !isEmptyObject(fieldValues) && fieldValues || defaultValue || defaultValuesRef.current;\n    return fieldNames && fieldNames.nest ? transformToNestObject(result) : result;\n  }\n\n  function unregister(names) {\n    if (!isEmptyObject(fieldsRef.current)) {\n      (isArray(names) ? names : [names]).forEach(function (fieldName) {\n        return removeEventListenerAndRef(fieldsRef.current[fieldName], true);\n      });\n    }\n  }\n\n  function registerFieldsRef(ref) {\n    var validateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!ref.name) {\n      return console.warn('Missing name @', ref);\n    }\n\n    var name = ref.name,\n        type = ref.type,\n        value = ref.value;\n    var fieldAttributes = Object.assign({\n      ref: ref\n    }, validateOptions);\n    var fields = fieldsRef.current;\n    var isRadioOrCheckbox = isRadioInput(type) || isCheckBoxInput(type);\n    var currentField = fields[name];\n\n    if (isRadioOrCheckbox ? currentField && isArray(currentField.options) && currentField.options.find(function (_ref32) {\n      var ref = _ref32.ref;\n      return value === ref.value;\n    }) : currentField) {\n      fields[name] = Object.assign(Object.assign({}, currentField), validateOptions);\n      return;\n    }\n\n    if (type) {\n      var mutationWatcher = onDomRemove(ref, function () {\n        return removeEventListenerAndRef(fieldAttributes);\n      });\n\n      if (isRadioOrCheckbox) {\n        currentField = Object.assign({\n          options: [].concat(_toConsumableArray(currentField && currentField.options || []), [{\n            ref: ref,\n            mutationWatcher: mutationWatcher\n          }]),\n          ref: {\n            type: type,\n            name: name\n          }\n        }, validateOptions);\n      } else {\n        currentField = Object.assign(Object.assign({}, fieldAttributes), {\n          mutationWatcher: mutationWatcher\n        });\n      }\n    } else {\n      currentField = fieldAttributes;\n    }\n\n    fields[name] = currentField;\n\n    if (!isEmptyObject(defaultValuesRef.current)) {\n      var defaultValue = getDefaultValue(defaultValuesRef.current, name);\n\n      if (!isUndefined(defaultValue) && !isNameInFieldArray(fieldArrayNamesRef.current, name)) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (validationSchema && readFormState.current.isValid) {\n      validateSchemaIsValid();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit && readFormState.current.isValid) {\n        validateFieldCurry(currentField).then(function (error) {\n          var previousFormIsValid = isValidRef.current;\n\n          if (isEmptyObject(error)) {\n            validFieldsRef.current.add(name);\n          } else {\n            isValidRef.current = false;\n          }\n\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n\n    if (!defaultRenderValuesRef.current[name]) {\n      defaultRenderValuesRef.current[name] = getFieldValue(fields, currentField.ref);\n    }\n\n    if (!type) {\n      return;\n    }\n\n    var fieldToAttachListener = isRadioOrCheckbox && currentField.options ? currentField.options[currentField.options.length - 1] : currentField;\n    attachEventListeners({\n      field: fieldToAttachListener,\n      isRadioOrCheckbox: isRadioOrCheckbox,\n      handleChange: handleChangeRef.current\n    });\n  }\n\n  function register(refOrValidationOptions, validationOptions) {\n    if (isWindowUndefined || !refOrValidationOptions) {\n      return;\n    }\n\n    if (isString(refOrValidationOptions)) {\n      registerFieldsRef({\n        name: refOrValidationOptions\n      }, validationOptions);\n      return;\n    }\n\n    if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n      registerFieldsRef(refOrValidationOptions, validationOptions);\n      return;\n    }\n\n    return function (ref) {\n      return ref && registerFieldsRef(ref, refOrValidationOptions);\n    };\n  }\n\n  var handleSubmit = useCallback(function (callback) {\n    return function _callee8(e) {\n      var fieldErrors, fieldValues, fields, _ref33, errors, values, _ref34, _errors2, _values, key, field;\n\n      return _regeneratorRuntime.async(function _callee8$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              if (e) {\n                e.preventDefault();\n                e.persist();\n              }\n\n              fields = fieldsRef.current;\n\n              if (readFormState.current.isSubmitting) {\n                isSubmittingRef.current = true;\n                reRender();\n              }\n\n              _context10.prev = 3;\n\n              if (!validationSchema) {\n                _context10.next = 16;\n                break;\n              }\n\n              fieldValues = getFieldsValues(fields);\n              _context10.next = 8;\n              return _regeneratorRuntime.awrap(validateFieldsSchemaCurry(transformToNestObject(fieldValues)));\n\n            case 8:\n              _ref33 = _context10.sent;\n              errors = _ref33.errors;\n              values = _ref33.values;\n              errorsRef.current = errors;\n              fieldErrors = errors;\n              fieldValues = values;\n              _context10.next = 23;\n              break;\n\n            case 16:\n              _context10.next = 18;\n              return _regeneratorRuntime.awrap(Object.values(fields).reduce(function _callee7(previous, field) {\n                var resolvedPrevious, ref, name, fieldError;\n                return _regeneratorRuntime.async(function _callee7$(_context9) {\n                  while (1) {\n                    switch (_context9.prev = _context9.next) {\n                      case 0:\n                        if (field) {\n                          _context9.next = 2;\n                          break;\n                        }\n\n                        return _context9.abrupt(\"return\", previous);\n\n                      case 2:\n                        _context9.next = 4;\n                        return _regeneratorRuntime.awrap(previous);\n\n                      case 4:\n                        resolvedPrevious = _context9.sent;\n                        ref = field.ref, name = field.ref.name;\n\n                        if (fields[name]) {\n                          _context9.next = 8;\n                          break;\n                        }\n\n                        return _context9.abrupt(\"return\", Promise.resolve(resolvedPrevious));\n\n                      case 8:\n                        _context9.next = 10;\n                        return _regeneratorRuntime.awrap(validateFieldCurry(field));\n\n                      case 10:\n                        fieldError = _context9.sent;\n\n                        if (!fieldError[name]) {\n                          _context9.next = 15;\n                          break;\n                        }\n\n                        set(resolvedPrevious.errors, name, fieldError[name]);\n                        validFieldsRef.current.delete(name);\n                        return _context9.abrupt(\"return\", Promise.resolve(resolvedPrevious));\n\n                      case 15:\n                        if (fieldsWithValidationRef.current.has(name)) {\n                          validFieldsRef.current.add(name);\n                        }\n\n                        resolvedPrevious.values[name] = getFieldValue(fields, ref);\n                        return _context9.abrupt(\"return\", Promise.resolve(resolvedPrevious));\n\n                      case 18:\n                      case \"end\":\n                        return _context9.stop();\n                    }\n                  }\n                });\n              }, Promise.resolve({\n                errors: {},\n                values: {}\n              })));\n\n            case 18:\n              _ref34 = _context10.sent;\n              _errors2 = _ref34.errors;\n              _values = _ref34.values;\n              fieldErrors = _errors2;\n              fieldValues = _values;\n\n            case 23:\n              if (!isEmptyObject(fieldErrors)) {\n                _context10.next = 29;\n                break;\n              }\n\n              errorsRef.current = {};\n              _context10.next = 27;\n              return _regeneratorRuntime.awrap(callback(transformToNestObject(fieldValues), e));\n\n            case 27:\n              _context10.next = 47;\n              break;\n\n            case 29:\n              if (!submitFocusError) {\n                _context10.next = 46;\n                break;\n              }\n\n              _context10.t0 = _regeneratorRuntime.keys(fieldsRef.current);\n\n            case 31:\n              if ((_context10.t1 = _context10.t0()).done) {\n                _context10.next = 46;\n                break;\n              }\n\n              key = _context10.t1.value;\n\n              if (!get(fieldErrors, key)) {\n                _context10.next = 44;\n                break;\n              }\n\n              field = fieldsRef.current[key];\n\n              if (!field) {\n                _context10.next = 44;\n                break;\n              }\n\n              if (!field.ref.focus) {\n                _context10.next = 41;\n                break;\n              }\n\n              field.ref.focus();\n              return _context10.abrupt(\"break\", 46);\n\n            case 41:\n              if (!field.options) {\n                _context10.next = 44;\n                break;\n              }\n\n              field.options[0].ref.focus();\n              return _context10.abrupt(\"break\", 46);\n\n            case 44:\n              _context10.next = 31;\n              break;\n\n            case 46:\n              errorsRef.current = fieldErrors;\n\n            case 47:\n              _context10.prev = 47;\n              isSubmittedRef.current = true;\n              isSubmittingRef.current = false;\n              submitCountRef.current = submitCountRef.current + 1;\n              reRender();\n              return _context10.finish(47);\n\n            case 53:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, null, [[3,, 47, 53]]);\n    };\n  }, [reRender, submitFocusError, validateFieldCurry, validateFieldsSchemaCurry, validationSchema]);\n\n  var resetRefs = function resetRefs() {\n    errorsRef.current = {};\n    fieldsRef.current = {};\n    touchedFieldsRef.current = {};\n    validFieldsRef.current = new Set();\n    fieldsWithValidationRef.current = new Set();\n    defaultRenderValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    dirtyFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    isSubmittedRef.current = false;\n    isDirtyRef.current = false;\n    isValidRef.current = true;\n    submitCountRef.current = 0;\n  };\n\n  var reset = function reset(values) {\n    for (var _i = 0, _Object$values = Object.values(fieldsRef.current); _i < _Object$values.length; _i++) {\n      var value = _Object$values[_i];\n\n      if (value && value.ref && value.ref.closest) {\n        try {\n          value.ref.closest('form').reset();\n          break;\n        } catch (_a) {}\n      }\n    }\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(function (resetFieldArray) {\n      return isFunction(resetFieldArray) && resetFieldArray(values);\n    });\n    resetRefs();\n\n    if (values) {\n      defaultValuesRef.current = values;\n    }\n\n    reRender();\n  };\n\n  var getValues = function getValues(payload) {\n    var fieldValues = getFieldsValues(fieldsRef.current);\n    var outputValues = isEmptyObject(fieldValues) ? defaultValuesRef.current : fieldValues;\n    return payload && payload.nest ? transformToNestObject(outputValues) : outputValues;\n  };\n\n  useEffect(function () {\n    return function () {\n      isUnMount.current = true;\n      fieldsRef.current && Object.values(fieldsRef.current).forEach(function (field) {\n        return removeEventListenerAndRef(field, true);\n      });\n    };\n  }, [removeEventListenerAndRef]);\n\n  if (!validationSchema) {\n    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);\n  }\n\n  var formState = {\n    dirty: isDirtyRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isEmptyObject(fieldsRef.current) || isValidRef.current\n  };\n  var control = {\n    register: register,\n    unregister: unregister,\n    setValue: setValue,\n    formState: formState,\n    mode: {\n      isOnBlur: isOnBlur,\n      isOnSubmit: isOnSubmit\n    },\n    reValidateMode: {\n      isReValidateOnBlur: isReValidateOnBlur,\n      isReValidateOnSubmit: isReValidateOnSubmit\n    },\n    errors: errorsRef.current,\n    fieldsRef: fieldsRef,\n    resetFieldArrayFunctionRef: resetFieldArrayFunctionRef,\n    fieldArrayNamesRef: fieldArrayNamesRef,\n    isDirtyRef: isDirtyRef,\n    defaultValuesRef: defaultValuesRef\n  };\n  return {\n    watch: watch,\n    control: control,\n    handleSubmit: handleSubmit,\n    setValue: setValue,\n    triggerValidation: triggerValidation,\n    getValues: useCallback(getValues, []),\n    reset: useCallback(reset, [reRender]),\n    register: useCallback(register, [defaultRenderValuesRef.current, defaultValuesRef.current]),\n    unregister: useCallback(unregister, [removeEventListenerAndRef]),\n    clearError: useCallback(clearError, []),\n    setError: useCallback(setError, []),\n    errors: errorsRef.current,\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: function get(obj, prop) {\n        if (prop in obj) {\n          readFormState.current[prop] = true;\n          return obj[prop];\n        }\n\n        return {};\n      }\n    }) : formState\n  };\n}\n\nvar FormGlobalContext = createContext(null);\n\nfunction useFormContext() {\n  return useContext(FormGlobalContext);\n}\n\nfunction FormContext(_a) {\n  var children = _a.children,\n      formState = _a.formState,\n      errors = _a.errors,\n      restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\n\n  return createElement(FormGlobalContext.Provider, {\n    value: Object.assign(Object.assign({}, restMethods), {\n      formState: formState,\n      errors: errors\n    })\n  }, children);\n}\n\nvar generateId = function generateId() {\n  var d = performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nvar appendId = function appendId(value) {\n  return Object.assign(Object.assign({}, value), {\n    id: generateId()\n  });\n};\n\nvar mapIds = function mapIds(data) {\n  return (isArray(data) ? data : []).map(function (value) {\n    return appendId(value);\n  });\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\n  var isMatch = false;\n\n  if (referenceArray.length !== differenceArray.length) {\n    return true;\n  }\n\n  for (var i = 0; i < referenceArray.length; i++) {\n    if (isMatch) {\n      break;\n    }\n\n    var _a = referenceArray[i],\n        data = __rest(_a, [\"id\"]);\n\n    if (!differenceArray[i] || Object.keys(data).length !== Object.keys(differenceArray[i]).length) {\n      isMatch = true;\n      break;\n    }\n\n    for (var key in data) {\n      if (!differenceArray[i][key] || data[key] !== differenceArray[i][key]) {\n        isMatch = true;\n        break;\n      }\n    }\n  }\n\n  return isMatch;\n}\n\nfunction useFieldArray(_ref35) {\n  var control = _ref35.control,\n      name = _ref35.name;\n  var methods = useFormContext();\n\n  var _ref36 = control || methods.control,\n      resetFieldArrayFunctionRef = _ref36.resetFieldArrayFunctionRef,\n      fieldArrayNamesRef = _ref36.fieldArrayNamesRef,\n      fieldsRef = _ref36.fieldsRef,\n      defaultValuesRef = _ref36.defaultValuesRef,\n      unregister = _ref36.unregister,\n      isDirtyRef = _ref36.isDirtyRef;\n\n  var memoizedDefaultValues = useMemo(function () {\n    return get(defaultValuesRef.current, name, []);\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [name]);\n\n  var _useState$ = useState$1(mapIds(memoizedDefaultValues)),\n      _useState$2 = _slicedToArray(_useState$, 2),\n      fields = _useState$2[0],\n      setField = _useState$2[1];\n\n  var resetFields = function resetFields(flagOrFields) {\n    isDirtyRef.current = isUndefined(flagOrFields) ? true : getIsFieldsDifferent(flagOrFields, memoizedDefaultValues);\n\n    for (var key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name)) {\n        unregister(key);\n      }\n    }\n  };\n\n  var append = function append(value) {\n    isDirtyRef.current = true;\n    setField([].concat(_toConsumableArray(fields), [appendId(value)]));\n  };\n\n  var prepend = function prepend(value) {\n    resetFields();\n    setField(mapIds([appendId(value)].concat(_toConsumableArray(fields))));\n  };\n\n  var remove = function remove(index) {\n    var data = isUndefined(index) ? [] : [].concat(_toConsumableArray(fields.slice(0, index)), _toConsumableArray(fields.slice(index + 1)));\n    resetFields(data);\n    setField(mapIds(data));\n  };\n\n  var insert = function insert(index, value) {\n    resetFields();\n    setField(mapIds([].concat(_toConsumableArray(fields.slice(0, index)), [appendId(value)], _toConsumableArray(fields.slice(index)))));\n  };\n\n  var swap = function swap(indexA, indexB) {\n    var _ref37 = [fields[indexB], fields[indexA]];\n    fields[indexA] = _ref37[0];\n    fields[indexB] = _ref37[1];\n    resetFields(fields);\n    setField(mapIds(_toConsumableArray(fields)));\n  };\n\n  var move = function move(from, to) {\n    fields.splice(to, 0, fields.splice(from, 1)[0]);\n    resetFields(fields);\n    setField(mapIds(_toConsumableArray(fields)));\n  };\n\n  var reset = function reset(values) {\n    resetFields();\n    setField(mapIds(get(values, name)));\n  };\n\n  useEffect$1(function () {\n    var resetFunctions = resetFieldArrayFunctionRef.current;\n    var fieldArrayNames = fieldArrayNamesRef.current;\n    fieldArrayNames.add(name);\n    resetFunctions[name] = reset;\n    return function () {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [name]);\n  return {\n    swap: swap,\n    move: move,\n    prepend: prepend,\n    append: append,\n    remove: remove,\n    insert: insert,\n    fields: fields\n  };\n}\n\nvar getInputValue = function getInputValue(target, isCheckbox) {\n  if (isNullOrUndefined(target)) {\n    return target;\n  }\n\n  return isCheckbox ? isUndefined(target.checked) ? target : target.checked : isUndefined(target.value) ? target : target.value;\n};\n\nvar Controller = function Controller(_a) {\n  var name = _a.name,\n      rules = _a.rules,\n      InnerComponent = _a.as,\n      onChange = _a.onChange,\n      onBlur = _a.onBlur,\n      _a$onChangeName = _a.onChangeName,\n      onChangeName = _a$onChangeName === void 0 ? VALIDATION_MODE.onChange : _a$onChangeName,\n      _a$onBlurName = _a.onBlurName,\n      onBlurName = _a$onBlurName === void 0 ? VALIDATION_MODE.onBlur : _a$onBlurName,\n      valueName = _a.valueName,\n      defaultValue = _a.defaultValue,\n      control = _a.control,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onChange\", \"onBlur\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\"]);\n\n  var methods = useFormContext();\n\n  var _ref38 = control || methods.control,\n      defaultValuesRef = _ref38.defaultValuesRef,\n      setValue = _ref38.setValue,\n      register = _ref38.register,\n      unregister = _ref38.unregister,\n      errors = _ref38.errors,\n      _ref38$mode = _ref38.mode,\n      isOnSubmit = _ref38$mode.isOnSubmit,\n      isOnBlur = _ref38$mode.isOnBlur,\n      _ref38$reValidateMode = _ref38.reValidateMode,\n      isReValidateOnBlur = _ref38$reValidateMode.isReValidateOnBlur,\n      isReValidateOnSubmit = _ref38$reValidateMode.isReValidateOnSubmit,\n      isSubmitted = _ref38.formState.isSubmitted,\n      fieldsRef = _ref38.fieldsRef,\n      fieldArrayNamesRef = _ref38.fieldArrayNamesRef;\n\n  var _useState$3 = useState$1(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue),\n      _useState$4 = _slicedToArray(_useState$3, 2),\n      value = _useState$4[0],\n      setInputStateValue = _useState$4[1];\n\n  var valueRef = useRef$1(value);\n  var isCheckboxInput = isBoolean(value);\n\n  var shouldValidate = function shouldValidate(isBlurEvent) {\n    return !skipValidation({\n      hasError: !!errors[name],\n      isBlurEvent: isBlurEvent,\n      isOnBlur: isOnBlur,\n      isOnSubmit: isOnSubmit,\n      isReValidateOnBlur: isReValidateOnBlur,\n      isReValidateOnSubmit: isReValidateOnSubmit,\n      isSubmitted: isSubmitted\n    });\n  };\n\n  var commonTask = function commonTask(target) {\n    var data = getInputValue(target, isCheckboxInput);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  var eventWrapper = function eventWrapper(event, eventName) {\n    return function () {\n      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {\n        arg[_key] = arguments[_key];\n      }\n\n      var data = commonTask(event(arg));\n      var isBlurEvent = eventName === EVENTS.BLUR;\n      setValue(name, data, shouldValidate(isBlurEvent));\n    };\n  };\n\n  var handleChange = function handleChange(e) {\n    var data = commonTask(e && e.target ? e.target : e);\n    setValue(name, data, shouldValidate());\n  };\n\n  var handleBlur = function handleBlur(e) {\n    var data = commonTask(e && e.target ? e.target : e);\n    setValue(name, data, shouldValidate(true));\n  };\n\n  var registerField = function registerField() {\n    return register(Object.defineProperty({\n      name: name\n    }, VALUE, {\n      set: function set(data) {\n        setInputStateValue(data);\n        valueRef.current = data;\n      },\n      get: function get() {\n        return valueRef.current;\n      }\n    }), Object.assign({}, rules));\n  };\n\n  if (!fieldsRef.current[name]) {\n    registerField();\n  }\n\n  useEffect$1(function () {\n    var fieldArrayNames = fieldArrayNamesRef.current;\n    registerField();\n    return function () {\n      if (!isNameInFieldArray(fieldArrayNames, name)) {\n        unregister(name);\n      }\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [name]);\n  var props = Object.assign(Object.assign(Object.assign(Object.assign({\n    name: name\n  }, rest), onChange ? _defineProperty({}, onChangeName, eventWrapper(onChange, EVENTS.CHANGE)) : _defineProperty({}, onChangeName, handleChange)), isOnBlur || isReValidateOnBlur ? onBlur ? _defineProperty({}, onBlurName, eventWrapper(onBlur, EVENTS.BLUR)) : _defineProperty({}, onBlurName, handleBlur) : {}), _defineProperty({}, valueName || (isCheckboxInput ? 'checked' : VALUE), value));\n  return isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, Object.assign({}, props));\n};\n\nvar ErrorMessage = function ErrorMessage(_ref43) {\n  var InnerComponent = _ref43.as,\n      errors = _ref43.errors,\n      name = _ref43.name,\n      children = _ref43.children;\n  var methods = useFormContext();\n\n  var _get = get(errors || methods.errors, name, {}),\n      message = _get.message,\n      types = _get.types;\n\n  if (!message) {\n    return null;\n  }\n\n  var props = {\n    children: children ? children({\n      message: message,\n      messages: types\n    }) : message\n  };\n  return InnerComponent ? isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, Object.assign({}, props)) : createElement(Fragment, Object.assign({}, props));\n};\n\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };","map":null,"metadata":{},"sourceType":"module"}